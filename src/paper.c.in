/*
  Paper sizes command-line utility.

  Copyright (c) 2021 Reuben Thomas <rrt@sc3d.org>.

  This program is free software: you can redistribute it and/or modify it
  under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or (at
  your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

#include "config.h"

#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <getopt.h>
#include <locale.h>

#include "progname.h"
#include "relocatable.h"
#include "xvasprintf.h"

#include "paper.h"


/* Options table. */
static struct option longopts[] = {
#define O(longname, shortname, arg, argstring, docstring) \
  {longname, arg, NULL, shortname},
#include "tbl_opts.h"
#undef O
  {0, 0, 0, 0}
};

static void usage(int exit_code)
{
    char *buf;
    fprintf(stderr, "Usage: %s [OPTION...] [PAPER...|--all]\n"
            "\n"
            "Print paper size information.\n"
            "\n",
            program_name);
#define O(longname, shortname, arg, argstring, docstring)       \
    buf = xasprintf("  --%s %s", longname, argstring);          \
    fprintf(stderr, "%-20s%s\n", buf, docstring);               \
    free(buf);
#include "tbl_opts.h"
#undef O
    fprintf(stderr, "\n"
            "Report bugs at " PACKAGE_URL "\n");
    exit(exit_code);
}

static void printinfo(const struct paper *paper, double dim, bool print_name, bool opt_size)
{
    if (print_name)
        printf("%s", papername(paper));

    if (opt_size) {
        if (print_name)
            putchar(' ');
        printf("%g %g", paperpswidth(paper) / dim, paperpsheight(paper) / dim);
    }

    putchar('\n');
}

_GL_ATTRIBUTE_FORMAT_PRINTF(1, 2) static void die(const char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    fprintf(stderr, "%s: ", program_name);
    vfprintf(stderr, fmt, ap);
    putc('\n', stderr);
    exit(1);
}

static void paper_die(const char *msg)
{
    die("%s in line %zu of %s", msg, paper_lineno, paper_specsfile);
}

int main(int argc, char **argv)
{
#ifdef ENABLE_RELOCATABLE
    set_program_name_and_installdir(argv[0], INSTALLPREFIX, INSTALLDIR);
#else
    set_program_name(argv[0]);
#endif
    setlocale(LC_ALL, "");

    /* Parse command-line options. */
    bool opt_all = false, opt_name = false, opt_size = false;
    double dim = unitfactor("pt");

    opterr = 0; /* Don't display errors for unknown options. */
    for (;;) {
        int this_optind = optind ? optind : 1, longindex = -1, c;

        /* Leading `:' so as to return ':' for a missing arg, not '?'. */
        c = getopt_long(argc, argv, ":", longopts, &longindex);

        if (c == -1) /* No more options. */
            break;
        else if (c == '?') /* Unknown option. */
            die("unknown option `%s'", argv[this_optind]);
        else if (c == ':') /* Missing argument. */
            die("option `%s' requires an argument", argv[this_optind]);

        switch (longindex) {
        case 0:
            opt_all = true;
            break;
        case 1:
            opt_name = true;
            break;
        case 2:
            opt_size = true;
            break;
        case 3:
            dim = unitfactor(optarg);
            if (dim == 0.0)
                die("%s", "bad unit (valid units: pt, mm, in)");
            break;
        case 4:
            usage(EXIT_SUCCESS);
            break;
        case 5:
            printf(PACKAGE_NAME " " VERSION "\n"
                   "Copyright (c) 2013-2021 Reuben Thomas <rrt@sc3d.org>.\n"
                   PACKAGE_NAME " comes with ABSOLUTELY NO WARRANTY.\n"
                   "You may redistribute copies of " PACKAGE_NAME "\n"
                   "under the terms of the GNU General Public License.\n"
                   "For more information about these matters, see the file named COPYING.\n");
            exit(EXIT_SUCCESS);
        default:
            break;
        }
    }

    /* Skip processed arguments. */
    argc -= optind;
    argv += optind;

    /* Check --all not used with explicit paper sizes. */
    if (opt_all && argc > 0)
        usage(1);

    /* Initialize libpaper. */
    int ret = paperinit();
    switch (ret) {
    case PAPER_OK:
        /* Do nothing. */
        break;
    case PAPER_BAD_WIDTH:
        paper_die("bad width");
        break;
    case PAPER_BAD_HEIGHT:
        paper_die("bad height");
        break;
    case PAPER_BAD_UNIT:
        paper_die("bad unit");
        break;
    case PAPER_ERROR:
        paper_die("out of memory");
        break;
    case PAPER_MISSING_FIELD:
        paper_die("missing field");
        break;
    default:
        paper_die("unknown error");
        break;
    }
    if (defaultpaper() == NULL)
        die("no paper sizes configured");

    int ret_code = EXIT_SUCCESS;

    if (opt_all) {
        for (const struct paper *p = paperfirst(); p; p = papernext(p))
            printinfo(p, dim, true, opt_size);
    } else {
        bool print_name = opt_name || !opt_size;
        if (argc > 1)
            opt_name = true;
        else if (argc == 0) {
            const struct paper *paper = defaultpaper();
            if (paper == NULL)
                die("no default paper size is set");
            printinfo(paper, dim, print_name, opt_size);
        }
        for (int i = 0; i < argc; i++) {
            const struct paper *paper = paperinfo(argv[i]);
            if (paper != NULL)
                printinfo(paper, dim, print_name, opt_size);
            else {
                printf("unknown paper `%s'\n", argv[i]);
                ret_code = EXIT_FAILURE;
            }
        }
    }

    exit(ret_code);
}
